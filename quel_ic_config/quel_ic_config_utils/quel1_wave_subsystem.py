import logging
import threading
import time
from concurrent.futures import Future, ThreadPoolExecutor
from enum import Enum
from queue import SimpleQueue
from typing import Any, Collection, Dict, Final, Iterator, List, Tuple, Union

import numpy as np
import numpy.typing as npt
from e7awgsw import AWG, AwgCtrl, CaptureCtrl, CaptureParam, WaveSequence

# Notes: importing CaptureCtrlRegs because some blocking APIs are too inconvenient
from e7awgsw.memorymap import CaptureCtrlRegs

# Notes: importing UdpRw to alter timeout duration (25s looks too long)
from e7awgsw.udpaccess import UdpRw

from quel_ic_config_utils.e7workaround import CaptureModule, CaptureUnit

logger = logging.getLogger(__name__)


class E7HwType(Enum):
    AUTO_DETECT = 0  # TODO: implement auto detection feature.
    SIMPLE_MULTI_CLASSIC = 1
    FEEDBACK_EARLY = 2
    NEC_EARLY = 3
    SIMPLE_MULTI_WIDER_RX = 4
    SENTINEL = 5


class CaptureReturnCode(Enum):
    CAPTURE_TIMEOUT = 1
    CAPTURE_ERROR = 2
    BROKEN_DATA = 3
    SUCCESS = 4


class CaptureResults(Iterator):
    def __init__(
        self,
        thunk: Future,
        q: "SimpleQueue[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]",
        num_iters: int,
    ):
        self._thunk = thunk
        self._q = q
        self._idx = 0
        self._num_iters = num_iters

    def __iter__(self) -> Iterator[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]:
        return self

    def __next__(self):
        if self._idx < self._num_iters:
            self._idx += 1
            return self._q.get()
        else:
            self._thunk.result()
            if not self._q.empty():
                raise AssertionError("extra data is generated by the capture thread")
            raise StopIteration()


# TODO: mutual exclusion should be moved to low-level library ASAP!
# TODO: find all the possible version dates of firmware!
class Quel1WaveSubsystem:
    DEFAULT_SIMPLE_CAPTURE_TIMEOUT: Final[float] = 0.5
    DEFAULT_CAPTURE_TIMEOUT: Final[float] = 60.0
    DEFAULT_NUM_WORKERS: Final[int] = 4  # possible maximum number of capture modules

    VERSION_TO_HWTYPE: Final[Dict[Tuple[str, str], E7HwType]] = {
        ("*", "2022/07/14"): E7HwType.SIMPLE_MULTI_CLASSIC,
        ("*", "*"): E7HwType.SIMPLE_MULTI_CLASSIC,  # DO NOT REMOVE THIS LINE
    }

    # number of AWGs of the e7awghw
    # Notes: currently awgctrl is almost common among hardwares and this data is not so meaningful.
    AWG_STRUCTURE: Final[Dict[E7HwType, int]] = {
        E7HwType.SIMPLE_MULTI_CLASSIC: 16,
        E7HwType.FEEDBACK_EARLY: 16,
        E7HwType.NEC_EARLY: 16,
        E7HwType.SIMPLE_MULTI_WIDER_RX: 16,
    }

    # module-unit-channel structure of the e7awghw.
    # Notes: be aware that the order of capunits within the inner mapping keeps significant information.
    MUC_STRUCTURE: Final[Dict[E7HwType, Dict[int, Dict[int, int]]]] = {
        E7HwType.SIMPLE_MULTI_CLASSIC: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 0,
                CaptureUnit.U2: 0,
                CaptureUnit.U3: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 0,
                CaptureUnit.U6: 0,
                CaptureUnit.U7: 0,
            },
        },
        E7HwType.FEEDBACK_EARLY: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 0,
                CaptureUnit.U2: 0,
                CaptureUnit.U3: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 0,
                CaptureUnit.U6: 0,
                CaptureUnit.U7: 0,
            },
            CaptureModule.U2: {
                CaptureUnit.U8: 0,
            },
            CaptureModule.U3: {
                CaptureUnit.U9: 0,
            },
        },
        E7HwType.NEC_EARLY: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U1: 0,
            },
            CaptureModule.U2: {
                CaptureUnit.U2: 0,
            },
            CaptureModule.U3: {
                CaptureUnit.U3: 0,
            },
        },
        E7HwType.SIMPLE_MULTI_WIDER_RX: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 1,
                CaptureUnit.U2: 2,
                CaptureUnit.U3: 3,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 1,
                CaptureUnit.U6: 2,
                CaptureUnit.U7: 3,
            },
        },
    }

    # workarounds
    _DEFAULT_TIMEOUT_OVERRIDE: Final[float] = 3.0
    UdpRw.TIMEOUT = _DEFAULT_TIMEOUT_OVERRIDE

    __slots__ = (
        "_wss_addr",
        "_hw_type",
        "_hw_version_cache",
        "_awgctrl",
        "_capctrl",
        "_executor",
        "_awgctrl_lock",
        "_capctrl_lock",
    )

    def __init__(self, wss_addr: str, hw_type: E7HwType = E7HwType.AUTO_DETECT):
        # execution control
        self._executor = ThreadPoolExecutor(max_workers=self.DEFAULT_NUM_WORKERS)
        self._awgctrl_lock = threading.Lock()
        self._capctrl_lock = threading.Lock()

        # resource management
        self._wss_addr: Final[str] = wss_addr
        self._hw_type = hw_type
        self._hw_version_cache: Union[None, Tuple[str, str]] = None

        self._awgctrl: Final[AwgCtrl] = AwgCtrl(self._wss_addr)
        self._capctrl: Final[CaptureCtrl] = CaptureCtrl(self._wss_addr)

    @staticmethod
    def _parse_xctrl_version(v: str, postfix: str) -> str:
        sv = v.split(":")
        if len(sv) != 2 and sv[0] == "K":
            raise RuntimeError(f"unexpected version string: '{v}'")
        ssv = sv[1].split("-")
        if len(ssv) != 2 and ssv[1] == postfix:
            raise RuntimeError(f"unexpected version string: '{v}'")
        return ssv[0]

    @property
    def hw_version(self) -> Tuple[str, str]:
        if self._hw_version_cache is None:
            with self._awgctrl_lock:
                awgv = self._parse_xctrl_version(self._awgctrl.version(), "1")
            with self._capctrl_lock:
                capv = self._parse_xctrl_version(self._capctrl.version(), "2")
            self._hw_version_cache = (awgv, capv)
        return self._hw_version_cache

    @property
    def hw_type(self) -> E7HwType:
        if self._hw_type is None:
            v = self.hw_version
            if v in self.VERSION_TO_HWTYPE:
                self._hw_type = self.VERSION_TO_HWTYPE[v]
            elif ("*", v[1]) in self.VERSION_TO_HWTYPE:
                self._hw_type = self.VERSION_TO_HWTYPE[("*", v[1])]
            elif (v[0], "*") in self.VERSION_TO_HWTYPE:
                self._hw_type = self.VERSION_TO_HWTYPE[(v[0], "*")]
            elif ("*", "*") in self.VERSION_TO_HWTYPE:
                self._hw_type = self.VERSION_TO_HWTYPE[("*", "*")]
                logger.warning(
                    "failed to resolve hardware features from the retrieved harware versions, "
                    f"conventional hw_type {self._hw_type} is assumed"
                )
            else:
                raise AssertionError
        return self._hw_type

    def get_num_available_awg(self) -> int:
        return self.AWG_STRUCTURE[self.hw_type]

    def get_muc_structure(self) -> Dict[int, Dict[int, int]]:
        return self.MUC_STRUCTURE[self.hw_type]

    def is_monitor_shared_with_read(self) -> bool:
        # TODO: re-consider how to implement this.
        return len(self.get_muc_structure()) == 2

    def get_num_capunits_of_capmod(self, capmod: int) -> int:
        return len(self.get_muc_structure()[capmod])

    def _validate_awg_hwidxs(self, awgs: Collection[int]) -> None:
        num_awgs = self.get_num_available_awg()
        if not all({0 <= awg < num_awgs for awg in awgs}):
            raise ValueError(f"invalid AWGs detected in ({','.join([str(a) for a in awgs])})")

    def _validate_capmod_hwidxs(self, capmods: Collection[int]) -> None:
        muc = self.get_muc_structure()
        if not all({capmod in muc for capmod in capmods}):
            raise ValueError(f"invalid capture modules detected in ({','.join([str(m) for m in capmods])})")

    def _get_capunit_hwidxs(self, capunits: Collection[Tuple[int, int]]) -> Dict[int, Tuple[int, int]]:
        """converting capmod-local index of capunit to its global index.

        :param capunits: a list of a pair of index of a capmod and capmod-local index of a capunit.
        :return: mapping from a global-index to the pair. the pair is convenient for name in the log.
        """
        muc = self.get_muc_structure()
        hwidxs: Dict[int, Tuple[int, int]] = {}
        for m, u in capunits:
            hwidx = tuple(muc[m].keys())[u]  # Notes: ordered dict
            hwidxs[hwidx] = m, u
        return hwidxs

    def initialize_awgs(self, awgs: Collection[int]):
        self._validate_awg_hwidxs(awgs)
        self._awgctrl.initialize(*awgs)
        self._awgctrl.terminate_awgs(*awgs)

    def initialize_all_awgs(self):
        awgs = AWG.all()
        self._validate_awg_hwidxs(awgs)
        self._awgctrl.initialize(*awgs)
        self._awgctrl.terminate_awgs(*awgs)

    def initialize_capunits(self, capunits: Collection[Tuple[int, int]]):
        hwidxs = self._get_capunit_hwidxs(capunits)
        self._capctrl.initialize(*hwidxs)

    def simple_capture(
        self,
        capmod: int,
        *,
        num_words: int = 1024,
        delay: int = 0,
        timeout: float = DEFAULT_SIMPLE_CAPTURE_TIMEOUT,
    ) -> Tuple[CaptureReturnCode, npt.NDArray[np.complex64]]:
        # Notes: paramters are validated in self.capture_start().
        future = self.simple_capture_start(
            capmod=capmod,
            capunits=(0,),
            num_words=num_words,
            delay=delay,
            triggering_awg=None,
            timeout=timeout,
        )

        # Notes: this case, no timeout handling is required here since capture module was activated definitely.
        status, data = future.result()
        if status in {CaptureReturnCode.BROKEN_DATA, CaptureReturnCode.SUCCESS}:
            return status, data[0]
        else:
            return status, np.zeros(0, dtype=np.complex64)

    def simple_capture_start(
        self,
        *,
        capmod: int,
        capunits: Collection[int],
        num_words: int,
        delay: int,
        triggering_awg: Union[int, None] = None,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> "Future[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]":
        self._validate_capmod_hwidxs({capmod})
        cuhwxs: Dict[int, Tuple[int, int]] = self._get_capunit_hwidxs([(capmod, capunit) for capunit in capunits])
        if triggering_awg is not None:
            self._validate_awg_hwidxs({triggering_awg})

        cap_prm = CaptureParam()
        cap_prm.num_integ_sections = 1
        cap_prm.add_sum_section(num_words=num_words, num_post_blank_words=1)
        cap_prm.capture_delay = delay

        self._setup_capture_units(capmod, cuhwxs, cap_prm, triggering_awg)
        return self._executor.submit(self._simple_capture_thread_main, cuhwxs, num_words, timeout)

    def capture_start(
        self,
        *,
        num_iters: int,
        capmod: int,
        capunits: Collection[int],
        num_words: int,
        delay: int,
        triggering_awg: int,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> CaptureResults:
        self._validate_capmod_hwidxs({capmod})
        cuhwxs: Dict[int, Tuple[int, int]] = self._get_capunit_hwidxs([(capmod, capunit) for capunit in capunits])
        if triggering_awg is not None:
            self._validate_awg_hwidxs({triggering_awg})

        cap_prm = CaptureParam()
        cap_prm.num_integ_sections = 1
        cap_prm.add_sum_section(num_words=num_words, num_post_blank_words=1)
        cap_prm.capture_delay = delay

        self._setup_capture_units(capmod, cuhwxs, cap_prm, triggering_awg)
        q: "SimpleQueue[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]" = SimpleQueue()
        return CaptureResults(
            self._executor.submit(self._capture_thread_main, q, num_iters, cuhwxs, num_words, timeout), q, num_iters
        )

    def _setup_capture_units(
        self,
        capmod: int,
        cuhwxs: Dict[int, Tuple[int, int]],
        cap_prm: CaptureParam,
        triggering_awg: Union[int, None] = None,
    ) -> None:
        with self._capctrl_lock:
            self._capctrl.initialize(*cuhwxs)
            for cuhwx in cuhwxs:
                self._capctrl.set_capture_params(cuhwx, cap_prm)
            # TODO: it looks better to dump status of capture units for debug.
            if triggering_awg is None:
                self._capctrl.start_capture_units(*cuhwxs)
            else:
                logger.info(
                    f"capture units {', '.join([str(capmu) for capmu in cuhwxs.values()])} "
                    f"will be triggered by awg {triggering_awg}"
                )
                self._capctrl.select_trigger_awg(capmod, triggering_awg)
                self._capctrl.enable_start_trigger(*cuhwxs)

    def _check_capture_units_done(self, cuhwxs: Dict[int, Tuple[int, int]]) -> bool:
        with self._capctrl_lock:
            for cuhwx in cuhwxs:
                # TODO: fix wrong usage of __ in e7awgsw
                val = self._capctrl._CaptureCtrl__reg_access.read_bits(
                    CaptureCtrlRegs.Addr.capture(cuhwx),
                    CaptureCtrlRegs.Offset.STATUS,
                    CaptureCtrlRegs.Bit.STATUS_DONE,
                    1,
                )
                if val == 0:
                    return False
            else:
                return True

    # TODO: improve the speed with using CaptureCtrlMaster register.
    def _clear_capture_unit_done(self, cuhwxs: Dict[int, Tuple[int, int]]):
        with self._capctrl_lock:
            for cuhwx in cuhwxs:
                for v in (0, 1):  # raising edge clears done flag
                    self._capctrl._CaptureCtrl__reg_access.write_bits(
                        CaptureCtrlRegs.Addr.capture(cuhwx),
                        CaptureCtrlRegs.Offset.CTRL,
                        CaptureCtrlRegs.Bit.CTRL_DONE_CLR,
                        1,
                        v,
                    )

    def _dump_capture_units_flags(self, cuhwxs: Dict[int, Tuple[int, int]]) -> None:
        with self._capctrl_lock:
            for cuhwx in cuhwxs:
                val = self._capctrl._CaptureCtrl__reg_access.read_bits(
                    CaptureCtrlRegs.Addr.capture(cuhwx),
                    CaptureCtrlRegs.Offset.STATUS,
                    0,
                    32,
                )
                wakeup = (val >> CaptureCtrlRegs.Bit.STATUS_WAKEUP) & 0x01
                busy = (val >> CaptureCtrlRegs.Bit.STATUS_BUSY) & 0x01
                done = (val >> CaptureCtrlRegs.Bit.STATUS_DONE) & 0x01
                logger.info(
                    f"status of capture unit {cuhwx} = 0x{val:08x}, (wakeup: {wakeup}, busy: {busy}, done: {done})"
                )

    def _wait_for_capture_data(self, cuhwxs: Dict[int, Tuple[int, int]], timeout: float) -> bool:
        # waiting for the completion of capturing
        polling_interval = min(max(0.01, timeout / 1000.0), 0.1)
        t0: float = time.perf_counter()
        completed: bool = False
        while time.perf_counter() - t0 < timeout:
            time.sleep(polling_interval)
            if self._check_capture_units_done(cuhwxs):
                completed = True
                break
        if completed:
            self._clear_capture_unit_done(cuhwxs)
        else:
            # TODO: investigate the reason this happens even when `timeout` is large enough
            logger.warning(f"timeout happens at capture units {', '.join([str(x) for x in cuhwxs])}, capture aborted")

        return completed

    def _check_capture_error(self, cuhwxs: Dict[int, Tuple[int, int]]) -> bool:
        with self._capctrl_lock:
            errdict: Dict[int, List[Any]] = self._capctrl.check_err(*cuhwxs)
        errflag = False
        for cuhwx, errlist in errdict.items():
            for err in errlist:
                logger.warning(f"capture unit {cuhwxs[cuhwx]}: {err}")
                errflag = True
        return errflag

    def _retrieve_capture_data(
        self, cuhwxs: Dict[int, Tuple[int, int]], num_words: int
    ) -> Tuple[CaptureReturnCode, Dict[Tuple[int, int], npt.NDArray[np.complex64]]]:
        data: Dict[Tuple[int, int], npt.NDArray[np.complex64]] = {}
        status: CaptureReturnCode = CaptureReturnCode.SUCCESS
        with self._capctrl_lock:
            for cuhwx, capunit in cuhwxs.items():
                n_sample_captured = self._capctrl.num_captured_samples(cuhwx)
                n_sample_expected = num_words * 4
                if n_sample_captured == n_sample_expected:
                    logger.info(f"the capture unit {self._wss_addr}:{capunit} captured {n_sample_captured} samples")
                else:
                    # TODO: investigate the reason this happens
                    logger.warning(
                        f"the capture unit {self._wss_addr}:{capunit} captured {n_sample_captured} samples, "
                        f"should be {n_sample_expected} samples"
                    )
                    status = CaptureReturnCode.BROKEN_DATA
                data_in_assq: List[Tuple[float, float]] = self._capctrl.get_capture_data(cuhwx, n_sample_captured)
                tmp = np.array(data_in_assq, dtype=np.float32)
                data[capunit] = tmp[:, 0] + tmp[:, 1] * 1j
        return status, data

    def _simple_capture_thread_main(
        self,
        cuhwxs: Dict[int, Tuple[int, int]],
        num_expected_words: int,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]:
        ready: bool = self._wait_for_capture_data(cuhwxs, timeout)
        if not ready:
            return CaptureReturnCode.CAPTURE_TIMEOUT, {}
        if self._check_capture_error(cuhwxs):
            return CaptureReturnCode.CAPTURE_ERROR, {}

        retcode, iqs = self._retrieve_capture_data(cuhwxs, num_expected_words)
        return retcode, {runit: iq for (_, runit), iq in iqs.items()}

    def _capture_thread_main(
        self,
        q: "SimpleQueue[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]",
        num_iters: int,
        cuhwxs: Dict[int, Tuple[int, int]],
        num_expected_words: int,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> None:
        for _ in range(num_iters):
            ready: bool = self._wait_for_capture_data(cuhwxs, timeout)
            if not ready:
                q.put((CaptureReturnCode.CAPTURE_TIMEOUT, {}))
                continue
            if self._check_capture_error(cuhwxs):
                q.put((CaptureReturnCode.CAPTURE_ERROR, {}))
                continue
            retcode, iqs_ = self._retrieve_capture_data(cuhwxs, num_expected_words)
            q.put((retcode, {runit: iq for (_, runit), iq in iqs_.items()}))
        return

    def simple_cw_gen(self, awg: int, amplitude: float, num_repeats: Tuple[int, int]) -> None:
        # Note: validation will be done in set_cw()
        self.set_cw(awg, amplitude, num_repeats)
        self.start_emission((awg,))

    def simple_iq_gen(self, awg: int, iq: npt.NDArray[np.complex64], num_repeats: Tuple[int, int]) -> None:
        # Note: validation will be done in set_iq()
        self.set_iq(awg, iq, num_repeats)
        self.start_emission((awg,))

    def set_cw(
        self,
        awg: int,
        amplitude: float,
        num_repeats: Tuple[int, int],
        num_wave_blocks: int = 1,
        num_wait_words: Tuple[int, int] = (0, 0),
    ) -> None:
        self._validate_awg_hwidxs({awg})
        wave = WaveSequence(num_wait_words=num_wait_words[0], num_repeats=num_repeats[0])
        iq = np.zeros(wave.NUM_SAMPLES_IN_WAVE_BLOCK * num_wave_blocks, dtype=np.complex64)
        iq[:] = 1 + 0j
        iq[:] *= amplitude
        block_assq: List[Tuple[int, int]] = list(zip(iq.real.astype(int), iq.imag.astype(int)))
        wave.add_chunk(iq_samples=block_assq, num_blank_words=num_wait_words[1], num_repeats=num_repeats[1])

        with self._awgctrl_lock:
            self._awgctrl.terminate_awgs(awg)  # to override current task of the unit
            # TODO: should wait for confirming the termination (?)
            self._awgctrl.set_wave_sequence(awg, wave)

    def set_iq(
        self,
        awg: int,
        iq: npt.NDArray[np.complex64],
        num_repeats: Tuple[int, int],
        num_wait_words: Tuple[int, int] = (0, 0),
    ) -> None:
        self._validate_awg_hwidxs({awg})
        wave = WaveSequence(num_wait_words=num_wait_words[0], num_repeats=num_repeats[0])
        block_assq: List[Tuple[int, int]] = list(zip(iq.real.astype(int), iq.imag.astype(int)))
        wave.add_chunk(iq_samples=block_assq, num_blank_words=num_wait_words[1], num_repeats=num_repeats[1])

        with self._awgctrl_lock:
            self._awgctrl.terminate_awgs(awg)  # to override current task of the unit
            # TODO: should wait for confirming the termination (?)
            self._awgctrl.set_wave_sequence(awg, wave)

    def clear_before_starting_emission(self, awgs: Collection[int]):
        self._validate_awg_hwidxs(awgs)
        with self._awgctrl_lock:
            self._awgctrl.clear_awg_stop_flags(*awgs)

    def start_emission(self, awgs: Collection[int]):
        self.clear_before_starting_emission(awgs)
        logger.info(f"start emission from AWGs {','.join([str(awg) for awg in awgs])}")
        with self._awgctrl_lock:
            self._awgctrl.start_awgs(*awgs)

    def stop_emission(self, awgs: Collection[int]):
        self._validate_awg_hwidxs(awgs)
        logger.info(f"stop emission from AWGs {','.join([str(awg) for awg in awgs])}")
        with self._awgctrl_lock:
            self._awgctrl.terminate_awgs(*awgs)
            # TODO: should wait for confirming the termination (?)


if __name__ == "__main__":
    from quel_ic_config import Quel1BoxType, Quel1ConfigOption, Quel1ConfigSubsystem
    from quel_ic_config_utils.e7resource_mapper import Quel1E7ResourceMapper

    logging.basicConfig(level=logging.INFO, format="{asctime} [{levelname:.4}] {name}: {message}", style="{")

    css = Quel1ConfigSubsystem(
        css_addr="10.5.0.74",
        boxtype=Quel1BoxType.QuEL1_TypeA,
        config_path=None,
        config_options=[Quel1ConfigOption.USE_READ_IN_MXFE0, Quel1ConfigOption.USE_READ_IN_MXFE1],
    )
    wss = Quel1WaveSubsystem(wss_addr="10.1.0.74", hw_type=E7HwType.SIMPLE_MULTI_CLASSIC)
    rmap = Quel1E7ResourceMapper(css, wss)

    assert css.configure_mxfe(0)
    assert css.configure_mxfe(1)
    css.set_lo_multiplier(group=0, line=0, freq_multiplier=85)
    css.set_dac_cnco(group=0, line=0, freq_in_hz=int(1500e6))
    css.set_dac_fnco(group=0, line=0, channel=0, freq_in_hz=int(0e6))
    css.set_sideband(group=0, line=0, sideband="U")
    css.set_vatt(group=0, line=0, vatt=0xA00)

    css.set_lo_multiplier(group=0, line="m", freq_multiplier=85)

    css.set_lo_multiplier(group=0, line=2, freq_multiplier=110)
    css.set_dac_cnco(group=0, line=2, freq_in_hz=int(1500e6))
    css.set_dac_fnco(group=0, line=2, channel=0, freq_in_hz=int(0e6))
    css.set_sideband(group=0, line=2, sideband="L")
    css.set_vatt(group=0, line=2, vatt=0xA00)

    # testing emission
    awg000 = rmap.get_awg_of_channel(0, 0, 0)
    wss.initialize_awgs({awg000})
    css.pass_line(group=0, line=0)
    wss.set_cw(awg000, 16383.0, (0xFFFFFFFF, 0xFFFFFFFF))
    wss.start_emission({awg000})
    input("hit any key to proceed")

    awg020 = rmap.get_awg_of_channel(0, 2, 0)
    wss.initialize_awgs({awg020})
    css.pass_line(group=0, line=2)
    wss.set_cw(awg020, 16383.0, (0xFFFFFFFF, 0xFFFFFFFF))
    wss.start_emission({awg020})
    input("hit any key to proceed")

    css.block_line(group=0, line=0)
    css.block_line(group=0, line=2)
    css.activate_monitor_loop(group=0)
    time.sleep(0.1)

    css.set_adc_cnco(group=0, rline="r", freq_in_hz=int(1350e6))
    css.set_adc_fnco(group=0, rline="r", rchannel=0, freq_in_hz=int(0))
    css.set_adc_cnco(group=0, rline="m", freq_in_hz=int(1100e6))
    css.set_adc_fnco(group=0, rline="m", rchannel=0, freq_in_hz=int(0))

    available_rlines = rmap.get_active_rlines_of_group(0)
    logger.info(f"activated rlines of group0 = {available_rlines}")
    assert len(available_rlines) == 1

    if tuple(available_rlines)[0] == "r":
        logger.info("captured data should have peak at 150MHz")
    elif tuple(available_rlines)[0] == "m":
        logger.info("captured data should have peak at -100MHz")
    else:
        raise AssertionError

    u0r = rmap.get_capture_module_of_rline(0, "r")
    wss.initialize_capunits({(u0r, 0)})
    retcode_r, data_r = wss.simple_capture(u0r)
    assert retcode_r == CaptureReturnCode.SUCCESS
    f_r = np.fft.fft(data_r)
    print(
        "[r] peak freq. = ", np.fft.fftfreq(len(data_r), 1 / 500e6)[np.argmax(abs(f_r))]
    )  # should be 150e6 if "r" is activated.
    print("[r] peak amplitude = ", np.max(abs(data_r)))

    u0m = rmap.get_capture_module_of_rline(0, "m")
    wss.initialize_capunits({(u0m, 0)})
    retcode_m, data_m = wss.simple_capture(u0m)
    assert retcode_m == CaptureReturnCode.SUCCESS
    f_m = np.fft.fft(data_m)
    print(
        "[m] peak freq. = ", np.fft.fftfreq(len(data_m), 1 / 500e6)[np.argmax(abs(f_m))]
    )  # should be -100e6 if "m" is activated.
    print("[m] peak amplitude = ", np.max(abs(data_m)))

    wss.stop_emission({awg000, awg020})
    input("hit any key to proceed")

    thunk = wss.simple_capture_start(capmod=u0r, capunits={0}, num_words=1024, delay=0, triggering_awg=awg000)
    time.sleep(0.5)
    wss.start_emission({awg000})
    retcode_rt, data_rts = thunk.result()
    data_rt = data_rts[0]
    wss.stop_emission({awg000})
    assert retcode_rt == CaptureReturnCode.SUCCESS
    f_rt = np.fft.fft(data_rt)
    print(
        "[r] peak freq. = ", np.fft.fftfreq(len(data_rt), 1 / 500e6)[np.argmax(abs(f_rt))]
    )  # should be -100e6 if "m" is activated.
    print("[r] peak amplitude = ", np.max(abs(data_rt)))

    input("hit any key to proceed")
    thunk = wss.simple_capture_start(capmod=u0m, capunits={0}, num_words=1024, delay=0, triggering_awg=awg020)
    time.sleep(0.5)
    wss.start_emission({awg020})
    retcode_mt, data_mts = thunk.result()
    data_mt = data_mts[0]
    wss.stop_emission({awg020})
    assert retcode_mt == CaptureReturnCode.SUCCESS
    f_mt = np.fft.fft(data_mt)
    print(
        "[m] peak freq. = ", np.fft.fftfreq(len(data_mt), 1 / 500e6)[np.argmax(abs(f_mt))]
    )  # should be -100e6 if "m" is activated.
    print("[m] peak amplitude = ", np.max(abs(data_mt)))
