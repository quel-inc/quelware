# 開発背景・基本設計方針

## 能書き
ユーザが必要とする制御装置の機能拡張をサクッと開発・提供するための枠組みを作る。

### ライブラリ開発の効率化
型ヒントとユニットテストが整備されており、また、関連する実装がコードの字面上で局在するように設計しているので、
機能追加によって予想外のパンチを食らう可能性をかなり低減できている。
従来のように、Cで記述した実行ファイルを呼び出すようなこともないので、異常の検出も容易になっている。

### ハードウェア・ファームウェアの変更への適応
FY2022のハードウェア開発時には、ソフトウェアの変更がまったく間に合わなかった。
FY2023はハードウェア納品時には、基本的な機能を網羅したソフトウェアも提供する。

#### 構成情報のデータ化
ハードウェアのモジュールの差し替えや追加に対して、局所的なコード改変で対応できるような設計になっている。

####  初期設定のコードからの分離
各世代および各タイプの制御装置ごとに、各種ICのレジスタの初期値をコードからなるべく独立して持てるようにした。
製品出荷時に標準の初期設定を付属するが、ユーザはオリジナルの初期値を作成することもできる。この際にコードを修正せずに済むのは
好ましい性質だ。

#### RAII?
コンストラクタで対応するファームウェアへの疎通確認まで済ませるか否かは、迷うところではある。
なんだが、ハードウェアコンポーネントがネットワークの向こう側におり、疎通確認に不確実性があるので、
今回はコンストラクタはハードウェアに触る準備（たとえば、OSが提供するリソースを確保する）までを分担し、
ハードウェアに実際に触りに行くのは、その後にするという設計ポリシーを採った。
このポリシーの嫌なところは、ハードウェアに触って初期化をする必要があるときに、面倒が発生するところにある。
つまり、コンストラクタを呼んだ後、他のメソッドを呼ぶ前に必ず初期化をしなければいけない、のだが、解決策が大なり小なり煩わしい。
一番簡単なのは、ユーザに明示的に初期化メソッドを呼ぶことを要求することだが、これは不親切すぎる。
また、初期化の結果に依存した処理をする各所で、何らかのチェックをする羽目になるのも厄介に拍車を掛ける。
そうなると、公開メソッドの先頭で必ず初期化の有無を確認し、まだであれば、自動的に初期化をする、という話になると思うのだが、
これも、各公開メソッドの先頭にボイラープレートを書かないといけないのが煩わしい。
なんだが、ここでは後者で行くことにする。
functools.cached_property あたりを使って、簡便に書くことができると思う。

## 全体像とか設計とか
cssの開発をしようとして始めたのだが、テスト用に書いたコードを発展させて、より上位のレイヤにまでカバーする方向にしようと思う。
当面は、正式にサポートするのはcssだけであり、boxレベル、あるいは、box内でcssと同じ階層に並ぶオブジェクトは、util扱いと
しておくが、いずれ、正式サポートに格上げする予定である。

### 階層構造
box の下に、 wss / sss / css の各コンポーネントが居る、という設計。
単一の制御装置についてはboxレベルのAPIを叩くことで、好きなことができるようになるのが最終形。

最終的には、box の上に qcsystem というレイヤを作って複数台を協働させる予定だが、未だほとんど白紙状態。
qcsystemを実現するための具体的な操作をする sss については、そこで使うはずのライブラリ(qube_master)の基本的な
動作確認をしている状態にとどまっている。

### css
group, line, channel の３つ組で対象を指し示す。この指し示し方はboxレイヤの下半分で導入するのが正しかったのかもしれない。
その場合には、css内部のマッピング(先述の３つ組 --> (ic_type, ic_idx) --> ExStickGEのファームウェアが定義する(bus, chip)）
の真ん中にある (ic_type, ic_idx) をAPI全面に出す形にできなくもないのだが、そうすることで特段便利になるわけでもないので、
CSSの表面で３つ組を使うことにした。

### wss
この API は、AWG / Capture Mod / Capture Unit といった概念でアクセスできるようにする。
e7awgsw の上半分とのI/Fを整理する意図で大胆にやってしまい、最終的には全体としての整合性を最適化する。

boxレイヤに css と wss との間を橋渡しする resource mapper（rmap) クラスを置く。
これは、次のような事情による。
- cssがboxと同一視できるくらい高レベルの抽象化を提供してしまっていることで、css と wssのリソースの関連付けにレイヤ的なアンバランスが生じているのをrmapnに閉じ込める。
    - cssを設計するときに、boxレイヤのイメージが固まって居なかったのが原因。最終的には　cssの上位部分の実装の一部をboxへ移して行く予定。
- e7awgswの柔軟性の欠如を改善できるまで、wssにe7awgswの上半分の代理をさせる必要があり、wssを可能な限りシンプルにしておきたかった。
    - e7awgswは一見、モジュール化されているように見えるが、ファームウェアの構成変更を吸収できるほどモジュール化できていない。別の言い方をすると、RTLレベルでのモジュールの追加や改変に小さい変更で追従したり、複数の構成を切り替えられるような作りになっていない。
- wss と css との間のリソースのマッピングは複雑に成り得るので、将来のファームウェア変更を吸収できる余地を確保しておきたい。

### sss
qube_master を取り込んで統一的なAPIとしてユーザに見せるべきなのだが、qcsystemのレイヤの設計を揉まないと着手できないので、
後回しになっている。

## テスト
近いうちに CI を立ち上げて自動的にテストが走るようになるが、それにしても、手元でテストをしたくなるだろう。
現状、静的解析とユニットテストを用意しており、最低でもこの２つをパスしないコードは`main`へのマージは禁止である。

### 依存リポジトリの配置について（要注意）
quel_ic_config は、qube_master のPythonインターフェースに依存している。
なので、`sugita_experimental`リポジトリと同じ階層に、`qube_master`リポジトリもクローンする必要がある。
クローンしていないと、`quel_clock_master` のシンボリックリンクが解決できない状態になるので、`ls`を色付き表示している人はすぐに気づくはずだ。 

現状はutil内のアルファ版APIとテストスクリプトだけで依存しているが、いずれ、本体にも依存コードが入る。
submodule で取り込んでもよかったのだが、本体に依存コードが入るタイミングで等価な機能のライブラリを`sugita_experimental`リポジトリ上で開発する予定である。
feedback用のAPI実装との絡みがあることと、`quelware`リポジトリの構成をなるべく単純にしたかった、というあたりが理由である。
なお、`quelware`リポジトリは変更後の構造を既に先取りしている。

### 静的解析
```shell
cd sugita_experimental/quel_ic_config
./static_check.sh
```

#### シンボリックリンクをつかった依存パッケージソースへの参照について
同じリポジトリ内の別ディレクトリで開発しているパッケージ3つと別リポジトリで開発しているパッケージ1つとへ、`quel_ic_config`のトップディレクトリからシンボリックリンクを張っている。
この理由は、主に静的解析の利便性のためである。
上述の `static_check.sh` の中に `PYTHONPATH` に列挙した方がいいのかもしれないが、単純で目立つ方法を取った。
なお、別リポジトリの依存をsubmoduleなどで管理していないことについては、上述のとおりである。
ここらへんは分かりにくくて申し訳ない。

#### 制御装置などのアドレスについて
コマンドライン引数のバリデータでは ip_address.IPv4Address でチェックをしているが、内部的にはアドレスを str で持っている。
一般的な使用状況では名前で引いて使う可能性などがあるので、IPv4Address型に制限してしまうのは現時点では乱暴だと感じるからである。
一方で、手動テスト時にIPアドレス直打ちで使うことが多いので、引数のバリデータ的で変なアドレスを弾くのは便利だと思う。
ここらへんも、アドレスの持ち方のポリシーを整備してから、実装をまともにしていく予定である。

なお、UDP/IPをハードウェア的に実現している部分があるので、近い将来にIPv6アドレスが使えるようになる、みたいなことは無いはず。

### ユニットテスト・結合テスト
実機を使ったユニットテストよりも大きい粒度のテストも含んでいるが、いずれにしても、全部をPASSする必要がある。

```shell
./runtest.sh -d S
```

- `-d` 指定の対象について実機を使ったテストを実施する。
   - `C`: simplemulti_classic版ファームウェア用のテスト
   - `S`: simplemulti_standard版ファームウェア用のテスト
   - `F`: feedback版ファームウェア用のテスト
   - `8`: QuEL-1 SE RIKEN8 用のテスト
- `-c` 指定の対象について、コマンドラインのスクリプトのテストも行う。
　　- `C`, `S`, `F` が使用可能。
- `-p` 指定の対象に向けに、仮想環境中のパッケージの再インストールと、ファームウェアの一時的な書き換えを行う。
    - `C`: 074, 058, 060 のSPI FLASH にかかれているファームウェアで再起動。
    - `S`: simplemulti_standard版の最新ファームウェアのbitファイルの内容で再起動。
    - `F`: feedback版の最新ファームウェアのbitファイルの内容で再起動。
- `-l` を付けると、テスト中のINFOレベルのログの表示を許可する。

マージをするためには、`-d` と `-c` の両方が付いた状態での全テスト通過が必須である。
実機テストは、現状、依存ライブラリやハードウェア的な不具合などで落ちることがある。
頻繁に発生する問題は例外などを捉えてリトライするようにしている。
当面は、エラーメッセージを目視で確認して、エラーが装置起因か変更起因かを判断して切り抜けて欲しい（残念）。

## 拡張モジュールのStubの管理
### 更新方法
`adi_ad9081_v106/__init__.pyi` は以下で生成したファイルに手で修正を加えて作成している。
```shell
PYTHONPATH=. pybind11-stubgen adi_ad9081_v106 --no-setup-py --root-module-suffix="" --ignore-invalid=all --output-dir="./generated"
```
手で加える修正は、変更前の adi_ad9081_v106 から `pybind11-stubgen` で生成した `__init__.pyi` と
リポジトリ内にある `adi_ad9081_v106/__init__.pyi` との差分を参照してほしい。
手修正が必要になるのは、配列データを引数に取るAPIなのだが、そのようなAPIが追加されていなければ、上記の差分が、作業終了時に保存されているはずである。
差分は`diff`コマンドで取得できるが、 `diff`コマンドの出力には行番号が含まれているので、単純に `diff` の　`diff` が空にはならないことに注意が必要だ。
