# 制御装置の排他的使用について
安全な実験環境を提供する目的で、使用中の制御装置に他の誰かがアクセスできないようにロックを掛ける仕組みを実装した。
制御装置の実装上の制約や、装置モデルごとのハードウェア的差異、また、ファームウェアの差異などで、いくつか注意すべき点があるので、ここでまとめて説明する。

## 排他制御の単位
### 空間的単位
quel_ic_config-0.10 が実装する排他制御の単位は、**制御装置全体**である。

2台のType-A と 1台のType-B を組み合わせて3台の制御装置で理研の16qubitをコントロールする場合には、Type-Bを1台まるごと握ると16qubit単位で握ることになる。
このことは、リソースの使用効率の観点からは好ましくないが、以下の実装上の問題が改善するまでは、quel_ic_config のレイヤでロックの単位を制御装置より細かい単位にするのは難しい。

- SIMPLEMULTIのコマンドキューが制御装置ごとに1つしかない。
  - コマンドキューにはコマンドを時刻順でキューしなければならず、複数人でコマンドキューを共用するには、キューを集中制御する必要がある。
  - コマンドキューのコマンドキャンセルの仕組みが、キュー内の全てのコマンドの一括キャンセルしかできない。
- AD9082がレジスタバンクの仕組みを持っているが、制御装置のAPIがバンク切り替えを抽象化しないで提供しているので、複数人の同時アクセスに集中管理が必要である。

一方で、制御装置のサーバのレイヤでは「集中管理」を実現できるので、アクセス制御単位の細粒度化はサーバのレイヤで行うのが適切であると考える。
サーバを用いる場合では、本ロックは、誤って複数のサーバが一台の制御装置を握ることを避ける機能を提供することになる。

なお、QuEL-3 では装置内にアプリケーションサーバを設けるのが自然な実装となると考えている。
サーバが提供するAPIは、高レベルなものになる想定で、柔軟なリソースの使用認可を妨げない設計になるだろう。
（デバグ・装置開発・メンテ用の低レベルAPIも開発する。低レベルAPIを使用する場合には、装置全体をロックするのが妥当だろう。）

### 時間的単位
排他制御の時間的単位は、**一連の実験期間全体**を想定している。
実験開始時にBoxオブジェクトを作成すると、実験終了時にそのBoxオブジェクトを破壊するまで、自分を含むいかなるユーザが同じ制御装置をターゲットに
Boxオブジェクトを作成することができなくなる。

ユーザがサーバ（[QubeServer](https://github.com/qiqb-osaka/qube-server)のようなものを想定するが、このサーバの使用をキュエル社として推奨する意図はない）
を介してアクセスする場合には、サーバの起動時にBoxオブジェクトが内部で作成され、終了時にBoxオブジェクトが破壊されると考えると、
サーバの生存期間と排他制御の生存期間は一致する。

話がやや脱線するが、 管理者権限をもったユーザがサーバを上げっぱなしにする運用では、ユーザが恩恵を預かれる排他制御はサーバが提供する機能に依存する。
つまり、当ロックはサーバが装置を独占使用することを保証するが、サーバを介して制御装置を利用するユーザは当ロックの存在を感知できない。

なお、管理者が立ち上げたサーバで管理される制御装置とユーザが直に叩く制御装置とが共存する環境でも、特別なことは発生しない。
サーバで管理された制御装置はサーバがロックを握っているので、ユーザがサーバを介さずにダイレクトに叩くことはできない。
逆も然りである。
ユーザがサーバ経由でアクセスする場合、認可はサーバの領分なので、当ロックとは関連が薄い話となり、特に混乱する要素はない。
整合性のある運用が可能なはずだ。

## 制御装置モデルごとの差異
QuEL-1以前の装置モデルと、QuEL-1 SE以降の装置モデルとでロックの実現方法が異なり、また、運用上の注意点も違ってくる。

QuEL-1 SE以降のモデルでは、制御装置自体にアクセス制御の仕組みを実装する。
具体的には、configuration subsystem (css) のファームウェアが特定のコネクション以外からの書き込みアクセスを遮断する仕組みを実装している。
この仕組みを「デバイスロック」と呼ぶ。
デバイスロックは、QuEL-1 SE用の cssファームウェア v1.3.0以降で実装されている。
それ以前のファームウェアでは、以下で説明する QuEL-1以前のモデルと同様のロックを使用することになる。

一方で、QuEL-1以前のモデルでは、デバイスロックの実装が困難である。
cssファームウェアを丸ごと作り直すことに成り兼ねない。
そこで、従来のe7awgswが実装していたロックファイルベースの仕組みを、制御装置全体に適用した「ファイルロック」をquel_ic_config が実装している。
ファイルロックでは、ロックファイルを作成するディレクトリが共有されていないホストPCからのアクセスは遮断できない、という大きな運用制約がある。
「無いよりマシ」という程度の実装であると考えて頂きたい。


| 制御装置モデル　       | 　cssファームウェアバージョン | 使用されるロックの実装 |  
|----------------|------------------|-------------|
| QuEL-1 以前      | N.A.             | ファイルロック     |
| QuEL-1 SE 以降 　 | v1.2.1以前 　       | ファイルロック     |
| QuEL-1 SE 以降   | v1.3.0以降         | デバイスロック　    |


なお、e7awgswのファイルロックと当ファイルロックは、導入目的や運用の発想が似て異なる。
e7awgswのファイルロックは、wssのファームウェア（e7awghw）に2つのコマンドパケットが同時に到着すると、コマンド解釈器がハングアップするという問題を避けることが主な目的であり、
ロックの時間的粒度をコマンド単位のような短い時間にする想定であった（と思う）。
quel_ic_config のファイルロックは、1つの実験全体の時間的粒度で排他使用を実現することを目的としている。

wssの短い時間粒度のロックは、制御装置の各ポートを別々のユーザが同時に使用するできる余地を残したい、という設計意図
に基づいているという解釈に見えるかもしれないが、SIMPLEMULTIのコマンドキューの仕組みがそもそもマルチユーザでの使用を許容しない作りになっているので、
そのような解釈には無理がある。
したがって、e7awgのロックはユーザ間での排他利用については適用外で、マルチユーザ環境では必ずサーバ経由で制御装置にアクセスしする
こととし、排他制御はサーバの分担とする、という解釈が妥当だと推測する。
この解釈に従うと、e7awgswのロックと当ロックとは、同じOSの仕組みを使っている全くの別物同士である、と考えるべきだ。

## ファイルロックについて
ファイルロックには運用上の注意点が多いので、以下の内容をよく理解することをお勧めする。
簡単に言うと、次のことに注意が必要だ。
- ソフトウェア実装なので、quel_ic_configのバージョンを最新に揃えるべき。古いバージョンが塞いでいない穴が抜け道になる。
- ロックファイルの作成場所が共有されているホストPC間でしか、ロックを保証できない。

### quel_ic_config のバージョンについて
quel_ic_config-0.10 は、e7awgsw に依存しておらず、独自のファイルロックの仕組みをもっている。
したがって、quel_ic_config-0.8およびそれ以前のもので、e7awgswに由来するロックファイルとの間に相互運用性はない。
同じ制御装置が、0.10以降と0.8以前のquel_ic_config で同時に使用される状況は避けるべきである。

### ロックファイルの置き場について
ロックファイルの作成ディレクトリは `/var/run/quelware` に固定である。
要望があれば可変にするが、可変にするメリットよりも、デメリットの方が大きいように感じる。

`/var/run/quelware` は運用者が予め作成する必要があるが、パーミッションの設定は運用ポリシーと相談である。
ロックファイルは、`/var/run/quelware`のパーミッションから、全てのxビットを削除したパーミッションで作成する。
ディレクトリのパーミッションが 755 であれば、ロックファイルは 644、770 なら 660 という具合である。
以下で、この設計意図を2つのユースケースを引き合いに説明する。

### 管理者権限を持った運用者が立ち上げたサーバ経由で、ユーザが制御装置にアクセスする場合
複数のサーバプロセスが1つの制御装置を同時に握ることを避けるのがロックの使い方となる。
ユーザがロックの取得をすることはできないので、ロックファイルはサーバプロセスのUIDで作成される。
したがって、`/var/run/quelware` はそのUIDで作成し、パーミッションは 700 なり 755 なりにしておけばよい。
ロックファイルは、600 なり、644 なりで作成されることになる。

### ユーザがquel_ic_config で制御装置で直接アクセスする場合
複数のユーザが自分のUIDで制御装置に直接アクセスすることを想定する。
自分用のサーバを自分のUIDで立ち上げる場合も、これのケースに準じる。

この場合、ロックファイルは使用者のUIDでの作成されるので、ディレクトリのパーミッションは777、グループ管理をするのであれば、775 あるいは 770 
あたりが妥当であろう。
ここで注意が必要なのは、ユーザAが作成したロックファイルはロックの解除後もディレクトリ上に残ることだ。
このファイルを削除しないと、ユーザBはロックファイルを作れないのは、あまりに不便なので、ロックを握っていないロックファイルは上書き可能にしておくのが妥当と考える。
悪意のあるユーザがロックファイルを故意に削除するのを防ぐといった、セキュリティ的な機能は、この仕組みの範疇外ということである。
紳士協定で成りったているマルチユーザ系での**ポカ防止**のための仕組みを超えたことはスコープ外である。

## デバイスロックについて
デバイスロックは、configuration subsystem (css)のファームウェアで実装されており、登録したソケット以外からの書き込みアクセスを遮断する。
したがって、ファイルロックにあった運用制約、ロックファイルのディレクトリを共有しているPCだけでしかロックが利かない、というような、分かりにくさがない。
しかし、ファイルロック共々、次の節で述べる点には注意が必要である。

## wssのロックについて
wssファームウェアに信頼できるなロック機構を実装するためには、大規模なファームウェアの改修が必要となり時間がかかる。
そこで、quel_ic_config-0.10 では、cssファームウェアのロックを参照して、ソフトウェアでwssファームウェアのアクセス制御を実現している。
これは、cssファームウェア側がデバイスロックであろうが、ファイルロックであろうが変わらない。

したがって、0.8.x以前の quel_ic_config との混用を避ける必要がある。
デバイスロックを使っている場合、0.8.x以前のquel_ic_config がロック無しでcssファームウェアにアクセスをした場合には、
適切に遮断される。
一方で、wssファームウェアは遮断の仕組みを持たないので、ホスト側でアクセスを発行してしまうと素通しになり、排他アクセスが崩れる。

同様の注意が、wss へのアクセスに quel_ic_configを使わずに独自の仕組みを使用する場合にも発生する。
現状で最良の対策は、独自の仕組みを cssファームウェアへのロック状態のチェックをしてから、wssファームウェアへのアクセスを
するように改修することだ。
box.has_lock プロパティを参照すれば、cssファームウェアのロック状態を参照できる。
（あるいは、css.has_lock プロパティでもよいが、キュエル社としては css APIの直接使用は非推奨である。）
実際には、ロックがない状態でboxオブジェクトを作成するためには、特別なことをしないといけないので、boxオブジェクトが
生きていれば、ロックが取れていると想定するでもそこそこ妥当である。

とはいえ、ここらへんは各サイトの運用ポリシー依存なので、危険性を許容した上で対策無しで使うといった判断も含め、自由にやって頂くのでよいと思う。
自由にやって頂いた部分については、キュエル社のサポートが限定的になるかもしれないことを認識した頂いていれば全く問題ない。

### デバイスロックの解除失敗について
結論から言うと、デバイスロックの解除失敗に伴う不便さを感じる状況が**ほとんど無い**ように作り込みをしているので、安心して頂きたい。

Boxオブジェクトのデストラクタが、ロックの解除を自動的に行うのだが、Pythonインタプリタと[通信に使っているライブラリ](https://aiocoap.readthedocs.io/en/latest/index.html)
との兼ね合いで、Pythonインタプリタの終了時にデストラクタが呼ばれてもロックの解除に失敗する。
ログに次のようなメッセージが出ることで、解除の失敗を知れるが、無視して頂いて問題ない。
```text
2024-09-18 11:09:33,905 [WARN] quel_ic_config.exstickge_coap_client: you should delete a box object (10.5.0.94) explicitly to release its lock properly
```
公式ツール群では、インタプリタの終了前に明示的に`del box`などとして、明示的にロックの解除をしている。
一方で、ユーザの実験コードにそれを求めるのは不便なので、2つの作り込みをしている。

まず、デバイスロックの寿命を60秒としている。
したがって、誰も使っていないはずの制御装置でロックの取得に失敗した場合には、最悪、60秒待てばよい。
なお、Boxオブジェクトがデバイスロックを自動更新するので、普段はユーザが寿命を意識する必要はない。
60秒経ってもロックが取得できない場合には、どこかで誰かのBoxオブジェクトが生きている、ということだ。

しかし、これだけでは十分に便利ではない。
実験コードの開発中に、ロックの開放に失敗したからといって、次の実行を60秒待たねばならないのは、あまりに辛い。
そこで、ロックの開放ができずにインタプリタが終了した場合には、`${HOME}/.quelware/recovery_keys/` にロックを
解除するためのリカバリキーが自動で保存される。
Boxオブジェクトの作成時に60秒以内に作成されたリカバリキーが存在する場合には、それを用いて古いロックの解除操作を行い、ロックの再取得をする。
全てが自動で行われるので、ユーザは何も意識しなくてよい。

なお、このリカバリキーは、他ユーザに共有することを想定していない。
また、ワンタイムの使用を想定している。
リカバリキーは毎度ランダムに生成され、また、ロックが取得されたままインタプリタが終了する際にだけファイルに書き出され、解除が終わると消去される。

#### 将来の方向性など
aiocoap を別ライブラリに差し替えるとロック開放失敗の発生頻度を緩和できるがゼロにはできないので、結局、現状の対策をしておくのが妥当だと思う。
そうなると、挿し替えることの利点が限定的なので、当面はこのままにする。
QuEL-3 ではプロセッサパワーに余裕があり、また、APIの粒度が大きくなるので、装置内にHTTPベースのアプリケーションサーバを走らせることになるだろう。
アクセスコントロールも、任意のこなれた手法を利用できるので、困ることはないだろう。
大規模なシステムでは、任意の予約システムとの連携が第一選択になるように思う。

## ロックの拡張について
ロックの仕組みを追加することが比較的容易に行える設計をしてある。
たとえば、ユーザが独自に運用している量子ビットの利用予約システムとロックを連動させる、といったことも実現可能である。
とはいっても、quel_ic_configで実装するロックには、バージョンを揃えないと抜けが発生する、という原理的な難しさがあるので、
QuEL-3 で開発予定のデバイス側で閉じたロック機構ができるまでは、あまり複雑なことをしないのが吉かもしれない。

## ロックの取得の主体についての正確な情報
これまで、ロックはBoxオブジェクトが管理しているという言い方をしてきたが、正確には、Quel1Box.css._proxy オブジェクトがロックを握っている。
このオブジェクトは、制御装置のGbEポートの先にあるFPGAボード(ExStickGE)との通信を握っている。
これは、QuEL-1 SEのデバイスロックをこのFPGAで実装していることに因る。

なお、10GbEの先にあるAlveo U50上のwssファームウェアに、まともなロック機構を実装するには大規模な開発が必要なので、先述のとおり、
cssファームウェアのロック状況に応じて、ホスト側ソフトウェアがwssのアクセス制御をする、という妥協をしている。
