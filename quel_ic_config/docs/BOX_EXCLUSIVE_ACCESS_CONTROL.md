# 制御装置の排他的使用について
安全な実験環境を提供する目的で、使用中の制御装置に他の誰かがアクセスできないようにロックを掛ける仕組みを実装した。
制御装置の実装上の制約や、装置モデルごとのハードウェア的差異、また、ファームウェアの差異などで、いくつか注意すべき点があるので、ここでまとめて説明する。

## 排他制御の単位
### 空間的単位
quel_ic_config-0.10 が実装する排他制御の単位は、**制御装置全体**である。

2台のType-A と 1台のType-B を組み合わせて3台の制御装置で理研の16qubitをコントロールする場合には、Type-Bを1台まるごと握ると16qubit単位で握ることになる。
このことは、リソースの使用効率の観点からは好ましくないが、以下の実装上の問題が改善するまでは、quel_ic_config のレイヤでロックの単位を制御装置より細かい単位にするのは難しい。

- SIMPLEMULTIのコマンドキューが制御装置ごとに1つしかない。
  - コマンドキューにはコマンドを時刻順でキューしなければならず、複数人でコマンドキューを共用するには、キューを集中制御する必要がある。
  - コマンドキューのコマンドキャンセルの仕組みが、キュー内の全てのコマンドの一括キャンセルしかできない。
- AD9082がレジスタバンクの仕組みを持っているが、制御装置のAPIがバンク切り替えを抽象化しないで提供しているので、複数人の同時アクセスに集中管理が必要である。

一方で、制御装置のサーバのレイヤでは「集中管理」を実現できるので、アクセス制御単位の細粒度化はサーバのレイヤで行うのが適切であると考える。
サーバを用いる場合では、本ロックは、誤って複数のサーバが一台の制御装置を握ることを避ける機能を提供することになる。

なお、QuEL-3 では装置内にアプリケーションサーバを設けるのが自然な実装となると考えている。
サーバが提供するAPIは、高レベルなものになる想定で、柔軟なリソースの使用認可を妨げない設計になるだろう。
（デバグ・装置開発・メンテ用の低レベルAPIも開発する。低レベルAPIを使用する場合には、装置全体をロックするのが妥当だろう。）

### 時間的単位
排他制御の時間的単位は、**一連の実験期間全体**を想定している。
実験開始時にBoxオブジェクトを作成すると、実験終了時にそのBoxオブジェクトを破壊するまで、自分を含むいかなるユーザが同じ制御装置をターゲットに
Boxオブジェクトを作成することができなくなる。

ユーザがサーバ（[QubeServer](https://github.com/qiqb-osaka/qube-server)のようなものを想定するが、このサーバの使用をキュエル社として推奨する意図はない）
を介してアクセスする場合には、サーバの起動時にBoxオブジェクトが内部で作成され、終了時にBoxオブジェクトが破壊されると考えると、
サーバの生存期間と排他制御の生存期間は一致する。

話がやや脱線するが、 管理者権限をもったユーザがサーバを上げっぱなしにする運用では、ユーザが恩恵を預かれる排他制御はサーバが提供する機能に依存する。
つまり、当ロックはサーバが装置を独占使用することを保証するが、サーバを介して制御装置を利用するユーザは当ロックの存在を感知できない。

なお、管理者が立ち上げたサーバで管理される制御装置とユーザが直に叩く制御装置とが共存する環境でも、特別なことは発生しない。
サーバで管理された制御装置はサーバがロックを握っているので、ユーザがサーバを介さずにダイレクトに叩くことはできない。
逆も然りである。
ユーザがサーバ経由でアクセスする場合、認可はサーバの領分なので、当ロックとは関連が薄い話となり、特に混乱する要素はない。
整合性のある運用が可能なはずだ。

## 制御装置モデルごとの差異
QuEL-1以前の装置モデルと、QuEL-1 SE以降の装置モデルとでロックの実現方法が異なり、また、運用上の注意点も違ってくる。

QuEL-1 SE以降のモデルでは、制御装置自体にアクセス制御の仕組みを実装する。
具体的には、configuration subsystem (css) のファームウェアが特定のコネクション以外からの書き込みアクセスを遮断する仕組みを実装している。
この仕組みを「デバイスロック」と呼ぶ。
デバイスロックは、QuEL-1 SE用の cssファームウェア v1.3.0以降で実装されている。
それ以前のファームウェアでは、以下で説明する QuEL-1以前のモデルと同様のロックを使用することになる。

一方で、QuEL-1以前のモデルでは、デバイスロックの実装が困難である。
cssファームウェアを丸ごと作り直すことに成り兼ねない。
そこで、従来のe7awgswが実装していたロックファイルベースの仕組みを、制御装置全体に適用した「ファイルロック」をquel_ic_config が実装している。
ファイルロックでは、ロックファイルを作成するディレクトリが共有されていないホストPCからのアクセスは遮断できない、という大きな運用制約がある。
「無いよりマシ」という程度の実装であると考えて頂きたい。
とはいえ、ロックディレクトリをNFSで共有しさえしておけば、複数のホストPC間でも制御装置の排他的利用が可能である。
ロックディレクトリの作成法ついては、後ほど説明する。

| 制御装置モデル　       | 　cssファームウェアバージョン | 使用されるロックの実装 |  
|----------------|------------------|-------------|
| QuEL-1 以前      | N.A.             | ファイルロック     |
| QuEL-1 SE 以降 　 | v1.2.1以前 　       | ファイルロック     |
| QuEL-1 SE 以降   | v1.3.0以降         | デバイスロック     |


なお、e7awgswのファイルロックと当ファイルロックは、導入目的や運用の発想が似て異なる。
e7awgswのファイルロックは、wssのファームウェア（e7awghw）に2つのコマンドパケットが同時に到着すると、コマンド解釈器がハングアップするという問題を避けることが主な目的であり、
ロックの時間的粒度をコマンド単位のような短い時間にする想定であった（と思う）。
quel_ic_config のファイルロックは、1つの実験全体の時間的粒度で排他使用を実現することを目的としている。

wssの短い時間粒度のロックは、制御装置の各ポートを別々のユーザが同時に使用するできる余地を残したい、という設計意図
に基づくという解釈が可能と思いきや、SIMPLEMULTIのコマンドキューの仕組みがそもそもマルチユーザでの使用を許容しない作りになっているので、
そのような解釈には無理がある。
したがって、e7awgswのロックはユーザ間での排他利用については適用外で、マルチユーザ環境では必ずサーバ経由で制御装置にアクセスしする
こととし、排他制御はサーバの分担とする、という解釈が妥当だと推測する。
この解釈に従うと、e7awgswのロックと当ロックとは、同じOSの仕組みを使っている全くの別物同士である、と考えるべきだ。

## ファイルロックについて
ファイルロックには運用上の注意点が多いので、以下の内容をよく理解することをお勧めする。
簡単に言うと、次のことに注意が必要だ。
- ソフトウェア実装なので、quel_ic_configのバージョンを最新に揃えるべき。古いバージョンが塞いでいない穴が抜け道になる。
- ロックファイルの作成場所が共有されているホストPC間でしか、ロックを保証できない。

### quel_ic_config のバージョンについて
quel_ic_config-0.10 は、e7awgsw に依存しておらず、独自のファイルロックの仕組みをもっている。
したがって、quel_ic_config-0.8およびそれ以前の e7awgswに由来するロックファイルとの間に相互運用性はない。
同じ制御装置が、0.10以降と0.8以前のquel_ic_config で同時に使用される状況は避けるべきである。

### ロックファイルの置き場と共有について
#### ロックディレクトリの作成
ロックファイルの作成ディレクトリは `/run/quelware` に固定である。
要望があれば可変にするが、可変にするメリットよりも、デメリットの方が大きいように感じる。

`/run/quelware` は運用者が用意する必要があるが、一般的に `/run` は tmpfs であるのが一般的なので、
Ubuntu-20.04LTS では、ブート時の自動作成の設定を `/etc/tmpfiles.d/` 以下のファイルに記述する。
まず、`/etc/tmpfiles.d/quelware-lock.conf` を次の内容で作成する。
```text
d /run/quelware 777 root root -
```
パーミッションの設定は運用ポリシーと相談であるが、全ユーザにサーバを介して制御装置にアクセスすることを強制するのでなければ、 777 や 775 に
設定するのが一般的だろう。
この設定を有効化するには、PCを再起動するか、あるいは、次のコマンドを実行する。
```shell
sudo systemd-tmpfiles --create
```

#### ロックディレクトリの共有（NFSサーバ側）
NFSを介して、他のホストPCと共有する場合には、次のようにするとよい。
以下では、`/run/quelware`を作成したホストを 10.0.0.100 としているが、実際の状況に合わせて書き換えて頂きたい。
まず、ディレクトリを保持するPC上で、`/run/quelware`をNFSで共有できるようにする。
もし、NFSサーバがインストールしていなければ、次の手順で、インストールからサーバの立ち上げまでを行う。
```shell
sudo apt update
sudo apt install nfs-kernel-server
```

NFSサーバのインストール時に作成される`/etc/exports` に次のような行を加え、`/run/quelware`の共有範囲を設定する。
以下は、10.0.0.0/24 のサブネット上の全てのPCに共有可とする場合である。
```text
/run/quelware 10.0.0.0/24(rw,sync,no_subtree_check)
```

最後に、この変更を有効にするのを忘れないように。
```shell
sudo exportfs -a
```

#### ロックディレクトリの共有（NFSクライアント側）
ロックディレクトリの共有を受ける側のPCでは、NFSクライアントが必要である。
インストールしていなければ、次の手順でインストールする。
```shell
sudo apt update
sudo apt install nfs-common
```

マウントポイントが必要なので、上述の[ロックディレクトリの作成](#ロックディレクトリの作成)の手順を行っておく必要がある。
`/etc/fstab`にマウントに次の行を加えて、マウントすれば準備完了である。
```text
10.0.0.100:/run/quelware      /run/quelware   nfs     defaults        0       2
```
最後の2は`/etc/fstab`の状況に応じて決定する必要があるが、デフォルト状態から変更がなければそのままで大丈夫なはずだ。

クライアントPCを再起動するか、あるいは、次のコマンドでマウントする。
```shell
sudo mount /run/quelware
```

### ファイルロックの解除失敗の対応
基本的にファイルロックの解除失敗はあまり発生しないはずで、シグナルでPythonインタプリタを停止させたり、Pythonインタプリタに組み込んだ
拡張モジュールがコアダンプしたりしなければ、ロックの解除が行われるはずだ。
お作法である `del box` をし損ねても、インタプリタの終了時の　atexit() フックでロックが解除している。

仮にロックの解除に失敗した場合でも、ロックの有効期限が15秒間に設定してあるので、誰も使っていない制御装置であれば、最悪でも15秒間待てばロック
を取得できる。その歳に次のようなエラーログが表示されるが無視しても安全である。
```text
2024-09-20 23:50:56,514 [ERRO] flufl.lock: lifetime has expired, breaking
```

誰も使っていない制御装置のロックを15秒待っても取得が出来ない場合には、ロックディレクトリに何らかの異常があると考えるべきだ。
パーミッションが正しくなかったり、異常なロックファイルが残っていたり、あるいは、ロックディレクトリをうまくマウントできていなったり、と
様々な理由が考えられる。
異常なロックファイルが残っている場合には、本当に当該装置を誰も使っていないことを確認の上、消去すれば解決するはずだ。
設定に問題がある場合には、エラーをメッセージの内容から問題を推定し対応することになるが、queware そのものの説明からは逸脱するので、
tmpfilesやNFSの設定についての資料をあたって頂きたい。

## デバイスロックについて
デバイスロックは、configuration subsystem (css)のファームウェアで実装されており、登録したソケット以外からの書き込みアクセスを遮断する。
したがって、ファイルロックにあった運用制約、ロックファイルのディレクトリを共有しているPCだけでしかロックが利かない、というような、分かりにくさが少ない。
しかし、ファイルロック共々、次の節で述べる点には注意が必要である。

### wssのロックについて
wssファームウェアに信頼できるなロック機構を実装するためには、大規模なファームウェアの改修が必要となり時間がかかる。
そこで、quel_ic_config-0.10 では、cssファームウェアのロックを参照して、ソフトウェアでwssファームウェアのアクセス制御を実現している。
これは、cssファームウェア側がデバイスロックであろうが、ファイルロックであろうが変わらない。

したがって、0.8.x以前の quel_ic_config との混用を避ける必要がある。
デバイスロックを使っている場合、0.8.x以前のquel_ic_config がロック無しでcssファームウェアにアクセスをした場合には、
適切に遮断される。
一方で、wssファームウェアは遮断の仕組みを持たないので、ホスト側でアクセスを発行してしまうと素通しになり、排他アクセスが崩れる。

同様の注意が、wss へのアクセスに quel_ic_configを使わずに独自の仕組みを使用する場合にも発生する。
現状で最良の対策は、独自の仕組みを cssファームウェアへのロック状態のチェックをしてから、wssファームウェアへのアクセスを
するように改修することだ。
box.has_lock プロパティを参照すれば、cssファームウェアのロック状態を参照できる。
（あるいは、css.has_lock プロパティでもよいが、キュエル社としては css APIの直接使用は非推奨である。）
実際には、ロックがない状態でboxオブジェクトを作成するためには、特別なことをしないといけないので、boxオブジェクトが
生きていれば、ロックが取れていると想定するでもそこそこ妥当である。

とはいえ、ここらへんは各サイトの運用ポリシー依存なので、危険性を許容した上で対策無しで使うといった判断も含め、自由にやって頂くのでよいと思う。
自由にやって頂いた部分については、キュエル社のサポートが限定的になるかもしれないことを認識した頂いていれば全く問題ない。

### デバイスロックの解除失敗について
結論から言うと、デバイスロックの解除失敗に伴う不便さを感じる状況が**ほとんど無い**ように作り込みをしているので、安心して頂きたい。

Boxオブジェクトのデストラクタが、ロックの解除を自動的に行うのだが、Pythonインタプリタと[通信に使っているライブラリ](https://aiocoap.readthedocs.io/en/latest/index.html)
との兼ね合いで、Pythonインタプリタの終了時にデストラクタが呼ばれてもロックの解除に失敗する。
ログに次のようなメッセージが出ることで、解除の失敗を知れるが、無視して頂いて問題ない。
```text
2024-09-18 11:09:33,905 [WARN] quel_ic_config.exstickge_coap_client: you should delete a box object (10.5.0.94) explicitly to release its lock properly
```
公式ツール群では、インタプリタの終了前に明示的に`del box`などとして、明示的にロックの解除をしている。
一方で、ユーザの実験コードにそれを求めるのは不便なので、2つの作り込みをしている。

まず、デバイスロックの寿命を60秒としている。
したがって、誰も使っていないはずの制御装置でロックの取得に失敗した場合には、最悪、60秒待てばよい。
なお、Boxオブジェクトがデバイスロックを自動更新するので、普段はユーザが寿命を意識する必要はない。
60秒経ってもロックが取得できない場合には、どこかで誰かのBoxオブジェクトが生きている、ということだ。

しかし、これだけでは十分に便利ではない。
実験コードの開発中に、ロックの開放に失敗したからといって、次の実行を60秒待たねばならないのは、あまりに辛い。
そこで、ロックの開放ができずにインタプリタが終了した場合には、`${HOME}/.quelware/recovery_keys/` にロックを
解除するためのリカバリキーが自動で保存される。
Boxオブジェクトの作成時に60秒以内に作成されたリカバリキーが存在する場合には、それを用いて古いロックの解除操作を行い、ロックの再取得をする。
全てが自動で行われるので、ユーザは何も意識しなくてよい。

なお、このリカバリキーは、他ユーザに共有することを想定していない。
また、ワンタイムの使用を想定している。
リカバリキーは毎度ランダムに生成され、また、ロックが取得されたままインタプリタが終了する際にだけファイルに書き出され、解除が終わると消去される。

### 将来の方向性など
aiocoap を別ライブラリに差し替えるとロック開放失敗の発生頻度を緩和できるがゼロにはできないので、結局、現状の対策をしておくのが妥当だと思う。
そうなると、挿し替えることの利点が限定的なので、当面はこのままにする。
QuEL-3 ではプロセッサパワーに余裕があり、また、APIの粒度が大きくなるので、装置内にHTTPベースのアプリケーションサーバを走らせることになるだろう。
アクセスコントロールも、任意のこなれた手法を利用できるので、困ることはなくなるはずだ。
大規模なシステムでは、任意の予約システム（認可サーバ）との連携が第一選択になるように思う。

## ロックの拡張について
ロックの仕組みを追加することが比較的容易に行える設計をしてある。
たとえば、ユーザが独自に運用している量子ビットの利用予約システムとロックを連動させる、といったことも実現可能である。
とはいっても、quel_ic_configで実装するロックには、バージョンを揃えないと抜けが発生する、という原理的な難しさがあるので、
QuEL-3 で開発予定のデバイス側で閉じたロック機構ができるまでは、あまり複雑なことをしないのが吉かもしれない。

## ロックの取得の主体についての正確な情報
これまで、ロックはBoxオブジェクトが管理しているという言い方をしてきたが、正確には、Quel1Box.css._proxy オブジェクトがロックを握っている。
このオブジェクトは、制御装置のGbEポートの先にあるFPGAボード(ExStickGE)との通信を握っている。
これは、QuEL-1 SEのデバイスロックをこのFPGAで実装していることに因る。

なお、10GbEの先にあるAlveo U50上のwssファームウェアに、まともなロック機構を実装するには大規模な開発が必要なので、先述のとおり、
cssファームウェアのロック状況に応じて、ホスト側ソフトウェアがwssのアクセス制御をする、という妥協をしている。
