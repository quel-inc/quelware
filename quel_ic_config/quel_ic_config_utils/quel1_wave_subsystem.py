import logging
import threading
import time
from concurrent.futures import Future, ThreadPoolExecutor
from enum import Enum
from functools import cached_property
from queue import SimpleQueue
from typing import Any, Collection, Dict, Final, Iterator, List, Mapping, Set, Tuple, Union

import numpy as np
import numpy.typing as npt
from e7awgsw import AWG, AwgCtrl, CaptureCtrl, CaptureParam, WaveSequence

# Notes: importing CaptureCtrlRegs because some blocking APIs are too inconvenient
from e7awgsw.memorymap import CaptureCtrlRegs

# Notes: importing UdpRw to alter timeout duration (25s looks too long)
from e7awgsw.udpaccess import UdpRw

from quel_ic_config_utils.e7workaround import (
    CaptureModule,
    CaptureUnit,
    E7FwLifeStage,
    E7FwType,
    E7LibBranch,
    detect_branch_of_library,
    resolve_hw_type,
)

logger = logging.getLogger(__name__)


class CaptureReturnCode(Enum):
    CAPTURE_TIMEOUT = 1
    CAPTURE_ERROR = 2
    BROKEN_DATA = 3
    SUCCESS = 4


class CaptureResults(Iterator):
    def __init__(
        self,
        thunk: Future,
        q: "SimpleQueue[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]",
        num_iters: int,
    ):
        self._thunk = thunk
        self._q = q
        self._idx = 0
        self._num_iters = num_iters

    def __iter__(self) -> Iterator[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]:
        return self

    def __next__(self):
        if self._idx < self._num_iters:
            self._idx += 1
            return self._q.get()
        else:
            self._thunk.result()
            if not self._q.empty():
                raise AssertionError("extra data is generated by the capture thread")
            raise StopIteration()


# TODO: mutual exclusion should be moved to low-level library ASAP!
# TODO: find all the possible version dates of firmware!
class Quel1WaveSubsystem:
    DEFAULT_SIMPLE_CAPTURE_TIMEOUT: Final[float] = 0.5
    DEFAULT_CAPTURE_TIMEOUT: Final[float] = 60.0
    DEFAULT_NUM_WORKERS: Final[int] = 4  # possible maximum number of capture modules

    VALID_HWTYPES_FOR_LIBRARY_BRANCH: Final[Mapping[E7LibBranch, Set[E7FwType]]] = {
        E7LibBranch.SIMPLEMULTI: {
            E7FwType.SIMPLEMULTI_CLASSIC,
        },
        E7LibBranch.FEEDBACK: {
            E7FwType.FEEDBACK_VERYEARLY,
            E7FwType.FEEDBACK_EARLY,
        },
    }

    # number of AWGs of the e7awghw
    # Notes: currently awgctrl is common among the most types of hardware and this data is not so meaningful.
    AWG_STRUCTURE: Final[Dict[E7FwType, int]] = {
        E7FwType.SIMPLEMULTI_CLASSIC: 16,
        E7FwType.FEEDBACK_VERYEARLY: 16,
        E7FwType.NEC_EARLY: 16,
        E7FwType.SIMPLEMULTI_WIDE: 16,
        E7FwType.FEEDBACK_EARLY: 16,
    }

    # module-unit-channel structure of the e7awghw.
    # Notes: be aware that the order of capunits within the inner mapping keeps significant information.
    MUC_STRUCTURE: Final[Dict[E7FwType, Dict[int, Dict[int, int]]]] = {
        E7FwType.SIMPLEMULTI_CLASSIC: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 0,
                CaptureUnit.U2: 0,
                CaptureUnit.U3: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 0,
                CaptureUnit.U6: 0,
                CaptureUnit.U7: 0,
            },
        },
        E7FwType.FEEDBACK_VERYEARLY: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 0,
                CaptureUnit.U2: 0,
                CaptureUnit.U3: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 0,
                CaptureUnit.U6: 0,
                CaptureUnit.U7: 0,
            },
            CaptureModule.U2: {
                CaptureUnit.U8: 0,
            },
            CaptureModule.U3: {
                CaptureUnit.U9: 0,
            },
        },
        E7FwType.FEEDBACK_EARLY: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 0,
                CaptureUnit.U2: 0,
                CaptureUnit.U3: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 0,
                CaptureUnit.U6: 0,
                CaptureUnit.U7: 0,
            },
            CaptureModule.U2: {
                CaptureUnit.U8: 0,
            },
            CaptureModule.U3: {
                CaptureUnit.U9: 0,
            },
        },
        # NOTES: not used yet
        E7FwType.NEC_EARLY: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
            },
            CaptureModule.U2: {
                CaptureUnit.U8: 0,
            },
            CaptureModule.U3: {
                CaptureUnit.U9: 0,
            },
        },
        # NOTES: not used yet
        E7FwType.SIMPLEMULTI_WIDE: {
            CaptureModule.U0: {
                CaptureUnit.U0: 0,
                CaptureUnit.U1: 1,
                CaptureUnit.U2: 2,
                CaptureUnit.U3: 3,
            },
            CaptureModule.U1: {
                CaptureUnit.U4: 0,
                CaptureUnit.U5: 1,
                CaptureUnit.U6: 2,
                CaptureUnit.U7: 3,
            },
        },
    }

    # workarounds
    _DEFAULT_TIMEOUT_OVERRIDE: Final[float] = 3.0
    UdpRw.TIMEOUT = _DEFAULT_TIMEOUT_OVERRIDE

    __slots__ = (
        "__dict__",  # TODO: remove it
        "_wss_addr",
        "_hw_type",
        "_hw_version_cache",
        "_awgctrl",
        "_capctrl",
        "_executor",
        "_awgctrl_lock",
        "_capctrl_lock",
    )

    def __init__(self, wss_addr: str, hw_type: E7FwType = E7FwType.AUTO_DETECT):
        # execution control
        self._executor = ThreadPoolExecutor(max_workers=self.DEFAULT_NUM_WORKERS)
        self._awgctrl_lock = threading.Lock()
        self._capctrl_lock = threading.Lock()

        # resource management
        self._wss_addr: Final[str] = wss_addr
        self._hw_type = hw_type

        self._awgctrl: Final[AwgCtrl] = AwgCtrl(self._wss_addr)
        self._capctrl: Final[CaptureCtrl] = CaptureCtrl(self._wss_addr)

    @cached_property
    def _integrity_between_firmware_and_library(self) -> bool:
        lib_branch = detect_branch_of_library()
        return self.hw_type in self.VALID_HWTYPES_FOR_LIBRARY_BRANCH[lib_branch]

    @cached_property
    def hw_version(self) -> Tuple[str, str, str]:
        with self._awgctrl_lock:
            awgv = self._awgctrl.version()
        with self._capctrl_lock:
            capv = self._capctrl.version()
        # TODO: sequencer version will be added in future.
        # Notes: current feedback version e7awgsw has a bug and SequencerCtrl.version() doesn't work well.
        return (awgv, capv, "")

    @cached_property
    def hw_type_and_lifestage(self) -> Tuple[E7FwType, E7FwLifeStage]:
        if self._hw_type is E7FwType.AUTO_DETECT:
            return resolve_hw_type(self.hw_version)
        else:
            logger.info(f"the hardware type is explicitly specified as {self._hw_type}")
            return self._hw_type, E7FwLifeStage.UNKNOWN

    @property
    def hw_type(self) -> E7FwType:
        return self.hw_type_and_lifestage[0]

    @property
    def hw_lifestage(self) -> E7FwLifeStage:
        return self.hw_type_and_lifestage[1]

    def get_num_available_awg(self) -> int:
        return self.AWG_STRUCTURE[self.hw_type]

    def get_muc_structure(self) -> Dict[int, Dict[int, int]]:
        return self.MUC_STRUCTURE[self.hw_type]

    def is_monitor_shared_with_read(self) -> bool:
        # TODO: re-consider how to implement this.
        # Notes: firmware configuration of SIMPLE_MULTI_WIDER_RX is not clarified.
        #        this implementation looks the best currently.
        return len(self.get_muc_structure()) == 2

    def get_num_capunits_of_capmod(self, capmod: int) -> int:
        return len(self.get_muc_structure()[capmod])

    def _validate_awg_hwidxs(self, awgs: Collection[int]) -> None:
        num_awgs = self.get_num_available_awg()
        if not all({0 <= awg < num_awgs for awg in awgs}):
            raise ValueError(f"invalid AWGs detected in ({','.join([str(a) for a in awgs])})")

    def _validate_capmod_hwidxs(self, capmods: Collection[int]) -> None:
        muc = self.get_muc_structure()
        if not all({capmod in muc for capmod in capmods}):
            raise ValueError(f"invalid capture modules detected in ({','.join([str(m) for m in capmods])})")

    def _get_capunit_hwidxs(self, capunits: Collection[Tuple[int, int]]) -> Dict[int, Tuple[int, int]]:
        """converting capmod-local index of capunit to its global index.

        :param capunits: a list of a pair of index of a capmod and capmod-local index of a capunit.
        :return: mapping from a global-index to the pair. the pair is convenient for name in the log.
        """
        muc = self.get_muc_structure()
        hwidxs: Dict[int, Tuple[int, int]] = {}
        for m, u in capunits:
            hwidx = tuple(muc[m].keys())[u]  # Notes: ordered dict
            hwidxs[hwidx] = m, u
        return hwidxs

    def validate_installed_e7awgsw(self):
        if not self._integrity_between_firmware_and_library:
            raise RuntimeError(f"mismatched e7awgsw library with box@{self._wss_addr}")

    def initialize_awgs(self, awgs: Collection[int]):
        self.validate_installed_e7awgsw()

        self._validate_awg_hwidxs(awgs)
        self._awgctrl.initialize(*awgs)
        self._awgctrl.terminate_awgs(*awgs)

    def initialize_all_awgs(self):
        self.validate_installed_e7awgsw()

        awgs = AWG.all()
        self._validate_awg_hwidxs(awgs)
        self._awgctrl.initialize(*awgs)
        self._awgctrl.terminate_awgs(*awgs)

    def initialize_capunits(self, capunits: Collection[Tuple[int, int]]):
        self.validate_installed_e7awgsw()

        hwidxs = self._get_capunit_hwidxs(capunits)
        self._capctrl.initialize(*hwidxs)

    def simple_capture(
        self,
        capmod: int,
        *,
        num_words: int = 1024,
        delay: int = 0,
        timeout: float = DEFAULT_SIMPLE_CAPTURE_TIMEOUT,
    ) -> Tuple[CaptureReturnCode, npt.NDArray[np.complex64]]:
        self.validate_installed_e7awgsw()

        # Notes: paramters are validated in self.capture_start().
        future = self.simple_capture_start(
            capmod=capmod,
            capunits=(0,),
            num_words=num_words,
            delay=delay,
            triggering_awg=None,
            timeout=timeout,
        )

        # Notes: this case, no timeout handling is required here since capture module was activated definitely.
        status, data = future.result()
        if status in {CaptureReturnCode.BROKEN_DATA, CaptureReturnCode.SUCCESS}:
            return status, data[0]
        else:
            return status, np.zeros(0, dtype=np.complex64)

    def simple_capture_start(
        self,
        *,
        capmod: int,
        capunits: Collection[int],
        num_words: int,
        delay: int,
        triggering_awg: Union[int, None] = None,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> "Future[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]":
        self.validate_installed_e7awgsw()

        self._validate_capmod_hwidxs({capmod})
        cuhwxs: Dict[int, Tuple[int, int]] = self._get_capunit_hwidxs([(capmod, capunit) for capunit in capunits])
        if triggering_awg is not None:
            self._validate_awg_hwidxs({triggering_awg})

        cap_prm = CaptureParam()
        cap_prm.num_integ_sections = 1
        cap_prm.add_sum_section(num_words=num_words, num_post_blank_words=1)
        cap_prm.capture_delay = delay

        self._setup_capture_units(capmod, cuhwxs, cap_prm, triggering_awg)
        return self._executor.submit(self._simple_capture_thread_main, cuhwxs, num_words, timeout)

    def capture_start(
        self,
        *,
        num_iters: int,
        capmod: int,
        capunits: Collection[int],
        num_words: int,
        delay: int,
        triggering_awg: int,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> CaptureResults:
        self.validate_installed_e7awgsw()

        self._validate_capmod_hwidxs({capmod})
        cuhwxs: Dict[int, Tuple[int, int]] = self._get_capunit_hwidxs([(capmod, capunit) for capunit in capunits])
        if triggering_awg is not None:
            self._validate_awg_hwidxs({triggering_awg})

        cap_prm = CaptureParam()
        cap_prm.num_integ_sections = 1
        cap_prm.add_sum_section(num_words=num_words, num_post_blank_words=1)
        cap_prm.capture_delay = delay

        self._setup_capture_units(capmod, cuhwxs, cap_prm, triggering_awg)
        q: "SimpleQueue[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]" = SimpleQueue()
        return CaptureResults(
            self._executor.submit(self._capture_thread_main, q, num_iters, cuhwxs, num_words, timeout), q, num_iters
        )

    def _setup_capture_units(
        self,
        capmod: int,
        cuhwxs: Dict[int, Tuple[int, int]],
        cap_prm: CaptureParam,
        triggering_awg: Union[int, None] = None,
    ) -> None:
        with self._capctrl_lock:
            self._capctrl.initialize(*cuhwxs)
            for cuhwx in cuhwxs:
                self._capctrl.set_capture_params(cuhwx, cap_prm)
            # TODO: it looks better to dump status of capture units for debug.
            if triggering_awg is None:
                self._capctrl.start_capture_units(*cuhwxs)
            else:
                logger.info(
                    f"capture units {', '.join([str(capmu) for capmu in cuhwxs.values()])} "
                    f"will be triggered by awg {triggering_awg}"
                )
                self._capctrl.select_trigger_awg(capmod, triggering_awg)
                self._capctrl.enable_start_trigger(*cuhwxs)

    def _check_capture_units_done(self, cuhwxs: Dict[int, Tuple[int, int]]) -> bool:
        with self._capctrl_lock:
            for cuhwx in cuhwxs:
                # TODO: fix wrong usage of __ in e7awgsw
                val = self._capctrl._CaptureCtrl__reg_access.read_bits(
                    CaptureCtrlRegs.Addr.capture(cuhwx),
                    CaptureCtrlRegs.Offset.STATUS,
                    CaptureCtrlRegs.Bit.STATUS_DONE,
                    1,
                )
                if val == 0:
                    return False
            else:
                return True

    # TODO: improve the speed with using CaptureCtrlMaster register.
    def _clear_capture_unit_done(self, cuhwxs: Dict[int, Tuple[int, int]]):
        with self._capctrl_lock:
            for cuhwx in cuhwxs:
                for v in (0, 1):  # raising edge clears done flag
                    self._capctrl._CaptureCtrl__reg_access.write_bits(
                        CaptureCtrlRegs.Addr.capture(cuhwx),
                        CaptureCtrlRegs.Offset.CTRL,
                        CaptureCtrlRegs.Bit.CTRL_DONE_CLR,
                        1,
                        v,
                    )

    def _dump_capture_units_flags(self, cuhwxs: Dict[int, Tuple[int, int]]) -> None:
        with self._capctrl_lock:
            for cuhwx in cuhwxs:
                val = self._capctrl._CaptureCtrl__reg_access.read_bits(
                    CaptureCtrlRegs.Addr.capture(cuhwx),
                    CaptureCtrlRegs.Offset.STATUS,
                    0,
                    32,
                )
                wakeup = (val >> CaptureCtrlRegs.Bit.STATUS_WAKEUP) & 0x01
                busy = (val >> CaptureCtrlRegs.Bit.STATUS_BUSY) & 0x01
                done = (val >> CaptureCtrlRegs.Bit.STATUS_DONE) & 0x01
                logger.info(
                    f"status of capture unit {cuhwx} = 0x{val:08x}, (wakeup: {wakeup}, busy: {busy}, done: {done})"
                )

    def _wait_for_capture_data(self, cuhwxs: Dict[int, Tuple[int, int]], timeout: float) -> bool:
        # waiting for the completion of capturing
        polling_interval = min(max(0.01, timeout / 1000.0), 0.1)
        t0: float = time.perf_counter()
        completed: bool = False
        while time.perf_counter() - t0 < timeout:
            time.sleep(polling_interval)
            if self._check_capture_units_done(cuhwxs):
                completed = True
                break
        if completed:
            self._clear_capture_unit_done(cuhwxs)
        else:
            # TODO: investigate the reason this happens even when `timeout` is large enough
            logger.warning(f"timeout happens at capture units {', '.join([str(x) for x in cuhwxs])}, capture aborted")

        return completed

    def _check_capture_error(self, cuhwxs: Dict[int, Tuple[int, int]]) -> bool:
        with self._capctrl_lock:
            errdict: Dict[int, List[Any]] = self._capctrl.check_err(*cuhwxs)
        errflag = False
        for cuhwx, errlist in errdict.items():
            for err in errlist:
                logger.warning(f"capture unit {cuhwxs[cuhwx]}: {err}")
                errflag = True
        return errflag

    def _retrieve_capture_data(
        self, cuhwxs: Dict[int, Tuple[int, int]], num_words: int
    ) -> Tuple[CaptureReturnCode, Dict[Tuple[int, int], npt.NDArray[np.complex64]]]:
        data: Dict[Tuple[int, int], npt.NDArray[np.complex64]] = {}
        status: CaptureReturnCode = CaptureReturnCode.SUCCESS
        with self._capctrl_lock:
            for cuhwx, capunit in cuhwxs.items():
                n_sample_captured = self._capctrl.num_captured_samples(cuhwx)
                n_sample_expected = num_words * 4
                if n_sample_captured == n_sample_expected:
                    logger.info(f"the capture unit {self._wss_addr}:{capunit} captured {n_sample_captured} samples")
                else:
                    # TODO: investigate the reason this happens
                    logger.warning(
                        f"the capture unit {self._wss_addr}:{capunit} captured {n_sample_captured} samples, "
                        f"should be {n_sample_expected} samples"
                    )
                    status = CaptureReturnCode.BROKEN_DATA
                data_in_assq: List[Tuple[float, float]] = self._capctrl.get_capture_data(cuhwx, n_sample_captured)
                tmp = np.array(data_in_assq, dtype=np.float32)
                data[capunit] = tmp[:, 0] + tmp[:, 1] * 1j
        return status, data

    def _simple_capture_thread_main(
        self,
        cuhwxs: Dict[int, Tuple[int, int]],
        num_expected_words: int,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]:
        ready: bool = self._wait_for_capture_data(cuhwxs, timeout)
        if not ready:
            return CaptureReturnCode.CAPTURE_TIMEOUT, {}
        if self._check_capture_error(cuhwxs):
            return CaptureReturnCode.CAPTURE_ERROR, {}

        retcode, iqs = self._retrieve_capture_data(cuhwxs, num_expected_words)
        return retcode, {runit: iq for (_, runit), iq in iqs.items()}

    def _capture_thread_main(
        self,
        q: "SimpleQueue[Tuple[CaptureReturnCode, Dict[int, npt.NDArray[np.complex64]]]]",
        num_iters: int,
        cuhwxs: Dict[int, Tuple[int, int]],
        num_expected_words: int,
        timeout: float = DEFAULT_CAPTURE_TIMEOUT,
    ) -> None:
        for _ in range(num_iters):
            ready: bool = self._wait_for_capture_data(cuhwxs, timeout)
            if not ready:
                q.put((CaptureReturnCode.CAPTURE_TIMEOUT, {}))
                continue
            if self._check_capture_error(cuhwxs):
                q.put((CaptureReturnCode.CAPTURE_ERROR, {}))
                continue
            retcode, iqs_ = self._retrieve_capture_data(cuhwxs, num_expected_words)
            q.put((retcode, {runit: iq for (_, runit), iq in iqs_.items()}))
        return

    def simple_cw_gen(self, awg: int, amplitude: float, num_repeats: Tuple[int, int]) -> None:
        # Note: validation will be done in set_cw()
        self.set_cw(awg, amplitude, num_repeats)
        self.start_emission((awg,))

    def simple_iq_gen(self, awg: int, iq: npt.NDArray[np.complex64], num_repeats: Tuple[int, int]) -> None:
        # Note: validation will be done in set_iq()
        self.set_iq(awg, iq, num_repeats)
        self.start_emission((awg,))

    def set_cw(
        self,
        awg: int,
        amplitude: float,
        num_repeats: Tuple[int, int],
        num_wave_blocks: int = 1,
        num_wait_words: Tuple[int, int] = (0, 0),
    ) -> None:
        self.validate_installed_e7awgsw()
        self._validate_awg_hwidxs({awg})
        wave = WaveSequence(num_wait_words=num_wait_words[0], num_repeats=num_repeats[0])
        iq = np.zeros(wave.NUM_SAMPLES_IN_WAVE_BLOCK * num_wave_blocks, dtype=np.complex64)
        iq[:] = 1 + 0j
        iq[:] *= amplitude
        block_assq: List[Tuple[int, int]] = list(zip(iq.real.astype(int), iq.imag.astype(int)))
        wave.add_chunk(iq_samples=block_assq, num_blank_words=num_wait_words[1], num_repeats=num_repeats[1])

        with self._awgctrl_lock:
            self._awgctrl.terminate_awgs(awg)  # to override current task of the unit
            # TODO: should wait for confirming the termination (?)
            self._awgctrl.set_wave_sequence(awg, wave)

    def set_iq(
        self,
        awg: int,
        iq: npt.NDArray[np.complex64],
        num_repeats: Tuple[int, int],
        num_wait_words: Tuple[int, int] = (0, 0),
    ) -> None:
        self.validate_installed_e7awgsw()
        self._validate_awg_hwidxs({awg})
        wave = WaveSequence(num_wait_words=num_wait_words[0], num_repeats=num_repeats[0])
        block_assq: List[Tuple[int, int]] = list(zip(iq.real.astype(int), iq.imag.astype(int)))
        wave.add_chunk(iq_samples=block_assq, num_blank_words=num_wait_words[1], num_repeats=num_repeats[1])

        with self._awgctrl_lock:
            self._awgctrl.terminate_awgs(awg)  # to override current task of the unit
            # TODO: should wait for confirming the termination (?)
            self._awgctrl.set_wave_sequence(awg, wave)

    def clear_before_starting_emission(self, awgs: Collection[int]):
        self.validate_installed_e7awgsw()
        self._validate_awg_hwidxs(awgs)
        with self._awgctrl_lock:
            self._awgctrl.clear_awg_stop_flags(*awgs)

    def start_emission(self, awgs: Collection[int]):
        self.validate_installed_e7awgsw()
        self.clear_before_starting_emission(awgs)
        logger.info(f"start emission from AWGs {','.join([str(awg) for awg in awgs])}")
        with self._awgctrl_lock:
            self._awgctrl.start_awgs(*awgs)

    def stop_emission(self, awgs: Collection[int]):
        self.validate_installed_e7awgsw()
        self._validate_awg_hwidxs(awgs)
        logger.info(f"stop emission from AWGs {','.join([str(awg) for awg in awgs])}")
        with self._awgctrl_lock:
            self._awgctrl.terminate_awgs(*awgs)
            # TODO: should wait for confirming the termination (?)
